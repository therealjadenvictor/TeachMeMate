<!DOCTYPE html>
<html>
<head>
  <title>SkillSwap - Video Call & Chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f5f5f5;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .back-btn {
      background: #999;
      padding: 10px 20px;
      margin-bottom: 20px;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    .back-btn:hover {
      background: #777;
    }

    .session-container {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      height: calc(100vh - 100px);
    }

    /* VIDEO SECTION */
    .video-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .video-container {
      flex: 1;
      background: #000;
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 300px;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-label {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      font-size: 13px;
      font-weight: bold;
    }

    .video-placeholder {
      color: #999;
      text-align: center;
      font-size: 14px;
    }

    .video-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      padding: 15px;
      background: white;
      border-radius: 10px;
      flex-wrap: wrap;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .control-btn {
      padding: 12px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 120px;
      justify-content: center;
    }

    .control-btn.active {
      background: #4CAF50;
      color: white;
    }

    .control-btn.inactive {
      background: #f44336;
      color: white;
    }

    .control-btn:hover {
      transform: scale(1.05);
    }

    .end-call-btn {
      background: #f44336;
      color: white;
      min-width: 150px;
    }

    .end-call-btn:hover {
      background: #da190b;
    }

    /* CHAT SECTION */
    .chat-section {
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      overflow: hidden;
      height: 100%;
    }

    .chat-header {
      padding: 15px 20px;
      background: #4CAF50;
      color: white;
      border-bottom: 1px solid #ddd;
      font-weight: bold;
      font-size: 16px;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: #f9f9f9;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }

    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .message {
      display: flex;
      margin-bottom: 5px;
    }

    .message.own {
      justify-content: flex-end;
    }

    .message-content {
      display: flex;
      flex-direction: column;
    }

    .message-bubble {
      max-width: 85%;
      padding: 10px 15px;
      border-radius: 10px;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.4;
    }

    .message.own .message-bubble {
      background: #4CAF50;
      color: white;
      border-bottom-right-radius: 2px;
    }

    .message.other .message-bubble {
      background: #e0e0e0;
      color: #333;
      border-bottom-left-radius: 2px;
    }

    .message-time {
      font-size: 11px;
      color: #999;
      margin-top: 3px;
      padding: 0 15px;
    }

    .message.own .message-time {
      text-align: right;
    }

    .message-empty {
      text-align: center;
      color: #999;
      padding: 20px;
      font-size: 14px;
    }

    .chat-input-area {
      padding: 15px 20px;
      border-top: 1px solid #ddd;
      display: flex;
      gap: 10px;
      background: white;
      flex-shrink: 0;
    }

    .chat-input-area input {
      flex: 1;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      font-family: 'Segoe UI', sans-serif;
    }

    .chat-input-area input:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
    }

    .chat-input-area button {
      padding: 12px 25px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
    }

    .chat-input-area button:hover {
      background: #45a049;
    }

    .chat-input-area button:active {
      transform: scale(0.98);
    }

    /* RESPONSIVE */
    @media (max-width: 1024px) {
      .session-container {
        grid-template-columns: 1fr;
        height: auto;
      }

      .chat-section {
        height: 400px;
      }

      .video-controls {
        flex-direction: column;
      }

      .control-btn {
        width: 100%;
        min-width: unset;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      .session-container {
        gap: 10px;
      }

      .video-section {
        gap: 5px;
      }

      .chat-header {
        padding: 10px 15px;
        font-size: 14px;
      }

      .chat-messages {
        padding: 10px 15px;
      }

      .chat-input-area {
        padding: 10px 15px;
        gap: 5px;
      }

      .message-bubble {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>

  <div class="container">
    <button class="back-btn" id="backBtn">‚Üê Back to Dashboard</button>
    
    <div class="session-container">
      <!-- VIDEO SECTION -->
      <div class="video-section">
        <!-- Local Video -->
        <div class="video-container">
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="video-label">You</div>
        </div>

        <!-- Remote Video -->
        <div class="video-container">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="video-label">Other User</div>
        </div>

        <!-- Controls -->
        <div class="video-controls">
          <button class="control-btn active" id="micBtn">
            <span>üé§</span>
            <span>Mic On</span>
          </button>
          <button class="control-btn active" id="cameraBtn">
            <span>üìπ</span>
            <span>Camera On</span>
          </button>
          <button class="control-btn" id="screenShareBtn">
            <span>üñ•Ô∏è</span>
            <span>Share Screen</span>
          </button>
          <button class="control-btn end-call-btn" id="endCallBtn">
            <span>üìû</span>
            <span>End Call</span>
          </button>
        </div>
      </div>

      <!-- CHAT SECTION -->
      <div class="chat-section">
        <div class="chat-header">üí¨ Chat</div>
        <div class="chat-messages" id="chatMessages">
          <div class="message-empty">No messages yet. Start chatting!</div>
        </div>
        <div class="chat-input-area">
          <input 
            type="text" 
            id="chatInput" 
            placeholder="Type a message..."
            autocomplete="off"
          >
          <button id="sendChatBtn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase Scripts -->
  <script type="module">
    // Import Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { 
    getAuth,
    onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { 
    getFirestore,
    collection,
    addDoc,
    query,
    where,
    onSnapshot,
    serverTimestamp,
    deleteDoc,
    doc
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // Firebase Config
    const firebaseConfig = {
    apiKey: "AIzaSyCWfzeXnsjSSL_ShSnZGEgorg6llFLxBJ0",
    authDomain: "teachmemate-347ab.firebaseapp.com",
    projectId: "teachmemate-347ab",
    storageBucket: "teachmemate-347ab.firebasestorage.app",
    messagingSenderId: "739144710255",
    appId: "1:739144710255:web:91de287fdbf35a8db4b59a"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ============================================
    // STATE MANAGEMENT
    // ============================================
    let currentUser = null;
    let matchId = null;
    let otherUserId = null;
    let peerConnection = null;
    let localStream = null;
    let remoteStream = null;
    let isMicOn = true;
    let isCameraOn = true;
    let isScreenSharing = false;

    // WebRTC Configuration
    const rtcConfig = {
    iceServers: [
        { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }
    ]
    };

    // ============================================
    // INITIALIZATION
    // ============================================

    // Get parameters from URL
    const params = new URLSearchParams(window.location.search);
    matchId = params.get('matchId');
    otherUserId = params.get('otherUserId');

    // Check auth
    onAuthStateChanged(auth, async (user) => {
    if (user) {
        currentUser = user;
        if (matchId && otherUserId) {
        await startCall();
        }
    } else {
        window.location.href = 'index.html';
    }
    });

    // ============================================
    // VIDEO CALL SETUP
    // ============================================

    async function startCall() {
    try {
        // Get local stream
        localStream = await navigator.mediaDevices.getUserMedia({
        video: {
            width: { ideal: 1280 },
            height: { ideal: 720 }
        },
        audio: {
            echoCancellation: true,
            noiseSuppression: true
        }
        });

        document.getElementById("localVideo").srcObject = localStream;

        // Create peer connection
        peerConnection = new RTCPeerConnection(rtcConfig);

        // Add local tracks
        localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
        });

        // Handle remote stream
        peerConnection.ontrack = (event) => {
        console.log("Remote track received");
        remoteStream = event.streams[0];
        document.getElementById("remoteVideo").srcObject = remoteStream;
        };

        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
        console.log("Connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === 'failed' || 
            peerConnection.connectionState === 'disconnected') {
            console.log("Connection lost, attempting to reconnect...");
        }
        };

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            sendSignalingMessage({
            type: "ice-candidate",
            candidate: event.candidate
            });
        }
        };

        // Create and send offer
        // Start listening first
        listenForSignaling();

        const isCaller = currentUser.uid < otherUserId;

        if (isCaller) {
        console.log("I am caller, creating offer");

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        await sendSignalingMessage({
            type: "offer",
            offer: offer
        });
        } else {
        console.log("Waiting for offer...");
        }


    } catch (error) {
        console.error("Error starting call:", error);
        alert("Could not access camera/microphone: " + error.message);
    }
    }

    // ============================================
    // SIGNALING
    // ============================================

    async function sendSignalingMessage(message) {
    try {
        await addDoc(collection(db, "signaling"), {
        from: currentUser.uid,
        to: otherUserId,
        matchId: matchId,
        message: message,
        createdAt: serverTimestamp()
        });
    } catch (error) {
        console.error("Error sending signaling message:", error);
    }
    }

    function listenForSignaling() {
    const q = query(
        collection(db, "signaling"),
        where("to", "==", currentUser.uid),
        where("from", "==", otherUserId),
        where("matchId", "==", matchId)
    );

    onSnapshot(q, async (snapshot) => {
        snapshot.docChanges().forEach(async (change) => {
        if (change.type === "added") {
            const data = change.doc.data();
            const msg = data.message;

            try {
            if (msg.type === "offer") {
                console.log("Received offer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                await sendSignalingMessage({
                type: "answer",
                answer: answer
                });
            } else if (msg.type === "answer") {
                console.log("Received answer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.answer));
            } else if (msg.type === "ice-candidate") {
                console.log("Received ICE candidate");
                try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(msg.candidate));
                } catch (e) {
                console.error("Error adding ICE candidate:", e);
                }
            }

            // Delete the signaling message after processing
            await deleteDoc(change.doc.ref);
            } catch (error) {
            console.error("Error processing signaling:", error);
            }
        }
        });
    });
    }

    // ============================================
    // VIDEO CONTROLS
    // ============================================

    document.getElementById("micBtn").addEventListener("click", function() {
    isMicOn = !isMicOn;
    
    if (localStream) {
        localStream.getAudioTracks().forEach(track => {
        track.enabled = isMicOn;
        });

        if (isMicOn) {
        this.classList.remove("inactive");
        this.classList.add("active");
        this.innerHTML = '<span>üé§</span><span>Mic On</span>';
        } else {
        this.classList.remove("active");
        this.classList.add("inactive");
        this.innerHTML = '<span>üé§</span><span>Mic Off</span>';
        }
    }
    });

    document.getElementById("cameraBtn").addEventListener("click", function() {
    isCameraOn = !isCameraOn;
    
    if (localStream) {
        localStream.getVideoTracks().forEach(track => {
        track.enabled = isCameraOn;
        });

        if (isCameraOn) {
        this.classList.remove("inactive");
        this.classList.add("active");
        this.innerHTML = '<span>üìπ</span><span>Camera On</span>';
        } else {
        this.classList.remove("active");
        this.classList.add("inactive");
        this.innerHTML = '<span>üìπ</span><span>Camera Off</span>';
        }
    }
    });

    document.getElementById("screenShareBtn").addEventListener("click", async function() {
    try {
        if (!isScreenSharing) {
        const screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: { cursor: 'always' },
            audio: false
        });

        const screenTrack = screenStream.getVideoTracks()[0];

        // Replace video track
        const sender = peerConnection
            .getSenders()
            .find(s => s.track && s.track.kind === 'video');

        if (sender) {
            await sender.replaceTrack(screenTrack);
        }

        isScreenSharing = true;
        this.classList.add("active");
        this.innerHTML = '<span>üñ•Ô∏è</span><span>Stop Share</span>';

        // Handle when user stops sharing from browser UI
        screenTrack.onended = async () => {
            isScreenSharing = false;
            this.classList.remove("active");
            this.innerHTML = '<span>üñ•Ô∏è</span><span>Share Screen</span>';

            // Switch back to camera
            const cameraTrack = localStream.getVideoTracks()[0];
            if (sender && cameraTrack) {
            await sender.replaceTrack(cameraTrack);
            }
        };
        } else {
        // Stop screen sharing
        const cameraTrack = localStream.getVideoTracks()[0];
        const sender = peerConnection
            .getSenders()
            .find(s => s.track && s.track.kind === 'video');

        if (sender && cameraTrack) {
            await sender.replaceTrack(cameraTrack);
        }

        isScreenSharing = false;
        this.classList.remove("active");
        this.innerHTML = '<span>üñ•Ô∏è</span><span>Share Screen</span>';
        }
    } catch (error) {
        console.error("Error sharing screen:", error);
        if (error.name !== 'NotAllowedError') {
        alert("Error sharing screen: " + error.message);
        }
    }
    });

    document.getElementById("endCallBtn").addEventListener("click", endCall);

    function endCall() {
    // Stop all tracks
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }

    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }

    // Clear videos
    document.getElementById("localVideo").srcObject = null;
    document.getElementById("remoteVideo").srcObject = null;

    // Go back
    window.location.href = 'dashboard.html';
    }

    // ============================================
    // CHAT FUNCTIONALITY
    // ============================================

    document.getElementById("sendChatBtn").addEventListener("click", sendChatMessage);
    document.getElementById("chatInput").addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
        sendChatMessage();
    }
    });

    async function sendChatMessage() {
    const chatInput = document.getElementById("chatInput");
    const message = chatInput.value.trim();

    if (!message) return;

    try {
        await addDoc(collection(db, "chats"), {
        matchId: matchId,
        senderId: currentUser.uid,
        senderName: currentUser.displayName || "Anonymous",
        message: message,
        createdAt: serverTimestamp()
        });

        chatInput.value = "";
        scrollChatToBottom();
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Error sending message: " + error.message);
    }
    }

    function listenToChat() {
    const q = query(
        collection(db, "chats"),
        where("matchId", "==", matchId)
    );

    onSnapshot(q, (snapshot) => {
        const messagesContainer = document.getElementById("chatMessages");
        
        // Clear empty message if exists
        const emptyMsg = messagesContainer.querySelector(".message-empty");
        if (emptyMsg && snapshot.size > 0) {
        emptyMsg.remove();
        }

        snapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
            const msg = change.doc.data();
            const isOwnMessage = msg.senderId === currentUser.uid;

            const messageEl = document.createElement("div");
            messageEl.className = `message ${isOwnMessage ? "own" : "other"}`;

            const time = msg.createdAt 
            ? new Date(msg.createdAt.toDate()).toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit' 
                })
            : "Now";

            messageEl.innerHTML = `
            <div class="message-content">
                <div class="message-bubble">${escapeHtml(msg.message)}</div>
                <div class="message-time">${time}</div>
            </div>
            `;

            messagesContainer.appendChild(messageEl);
        }
        });

        scrollChatToBottom();
    });
    }

    function scrollChatToBottom() {
    const messagesContainer = document.getElementById("chatMessages");
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
    }

    // ============================================
    // BACK BUTTON
    // ============================================

    document.getElementById("backBtn").addEventListener("click", () => {
    if (confirm("Are you sure you want to end this call?")) {
        endCall();
    }
    });

    // Start listening to chat after call starts
    setTimeout(() => {
    listenToChat();
    }, 1000);

    // Auto-end call if peer disconnects
    let disconnectTimeout;
    const checkConnection = setInterval(() => {
    if (peerConnection && peerConnection.connectionState === 'closed') {
        clearInterval(checkConnection);
        alert("Call ended by other user");
        endCall();
    }
    }, 5000);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    if (peerConnection) {
        peerConnection.close();
    }
    });
  </script>
</body>
</html>